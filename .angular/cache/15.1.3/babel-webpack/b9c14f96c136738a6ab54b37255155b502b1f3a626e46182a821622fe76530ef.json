{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { ChangeDetectionStrategy, Component } from '@angular/core';\nimport { BehaviorSubject, of } from 'rxjs';\nimport { catchError, map, startWith } from 'rxjs/operators';\nimport { DataState } from './enum/data-state.enum';\nimport { Status } from './enum/status.enum';\nlet AppComponent = class AppComponent {\n  constructor(serverService) {\n    this.serverService = serverService;\n    this.DataState = DataState;\n    this.Status = Status;\n    this.filterSubject = new BehaviorSubject('');\n    this.dataSubject = new BehaviorSubject(null);\n    this.filterStatus$ = this.filterSubject.asObservable();\n    this.isLoading = new BehaviorSubject(false);\n    this.isLoading$ = this.isLoading.asObservable();\n  } // injection \n  // like a runnable in java, runs on startup\n  ngOnInit() {\n    this.appState$ = this.serverService.server$ // subscribe this observable that makes a http request \n    .pipe(map(response => {\n      this.dataSubject.next(response); // save the response in the dataSubject for pingServer()\n      return {\n        dataState: DataState.LOADED_STATE,\n        appData: response\n      };\n    }), startWith({\n      dataState: DataState.LOADING_STATE\n    }),\n    // waiting for data so we omit response\n    catchError(error => {\n      return of({\n        dataState: DataState.ERROR_STATE,\n        error\n      }); // if we catch an error\n    }));\n  }\n\n  pingServer(ipAddress) {\n    this.filterSubject.next(ipAddress);\n    this.appState$ = this.serverService.ping$(ipAddress).pipe(map(response => {\n      const index = this.dataSubject.value.data.servers.findIndex(server => server.id === response['data.server.id']);\n      this.dataSubject.value.data.servers[index] = response['data.server'];\n      this.filterSubject.next('');\n      return {\n        dataState: DataState.LOADED_STATE,\n        appData: this.dataSubject.value\n      };\n    }), startWith({\n      dataState: DataState.LOADED_STATE,\n      appData: this.dataSubject.value\n    }), catchError(error => {\n      this.filterSubject.next('');\n      return of({\n        dataState: DataState.ERROR_STATE,\n        error\n      });\n    }));\n  }\n  // Not getting any new data from the backend because we already have it in response\n  filterServer(status) {\n    this.appState$ = this.serverService.filter$(status, this.dataSubject.value).pipe(map(response => {\n      return {\n        dataState: DataState.LOADED_STATE,\n        appData: response\n      };\n    }), startWith({\n      dataState: DataState.LOADED_STATE,\n      appData: this.dataSubject.value\n    }), catchError(error => {\n      return of({\n        dataState: DataState.ERROR_STATE,\n        error\n      });\n    }));\n  }\n};\nAppComponent = __decorate([Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css'],\n  changeDetection: ChangeDetectionStrategy.OnPush\n})], AppComponent);\nexport { AppComponent };","map":{"version":3,"mappings":"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","names":["ChangeDetectionStrategy","Component","BehaviorSubject","of","catchError","map","startWith","DataState","Status","AppComponent","constructor","serverService","filterSubject","asObservable","isLoading","ngOnInit","appState$","server$","pipe","response","dataSubject","next","dataState","LOADED_STATE","appData","LOADING_STATE","error","ERROR_STATE","pingServer","ipAddress","ping$","index","value","data","servers","findIndex","server","id","filterServer","status","filter$","selector","templateUrl","styleUrls","changeDetection","OnPush"],"sourceRoot":"","sources":["C:\\Users\\lhs49\\Desktop\\Playspace\\reactive-spring\\serverapp\\src\\app\\app.component.ts"],"sourcesContent":["import { ChangeDetectionStrategy, Component, OnInit } from '@angular/core';\nimport { NgForm } from '@angular/forms';\nimport { BehaviorSubject, Observable, of } from 'rxjs';\nimport { catchError, map, startWith } from 'rxjs/operators';\nimport { DataState } from './enum/data-state.enum';\nimport { Status } from './enum/status.enum';\nimport { AppState } from './interface/app-state';\nimport { CustomResponse } from './interface/custom-response';\nimport { Server } from './interface/server';\n\nimport { ServerService } from './service/server.service';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css'],\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class AppComponent implements OnInit{\n  appState$: Observable<AppState<CustomResponse>>;\n  readonly DataState = DataState;\n  readonly Status = Status;\n  private filterSubject = new BehaviorSubject<string>('');\n  private dataSubject = new BehaviorSubject<CustomResponse>(null);\n  filterStatus$ = this.filterSubject.asObservable();\n  private isLoading = new BehaviorSubject<boolean>(false);\n  isLoading$ = this.isLoading.asObservable();\n\n\n  constructor(private serverService: ServerService){} // injection \n\n  // like a runnable in java, runs on startup\n  ngOnInit(): void {\n    this.appState$ = this.serverService.server$ // subscribe this observable that makes a http request \n    .pipe(\n      map(response => { // callback when ever there is a response from the server\n        this.dataSubject.next(response) // save the response in the dataSubject for pingServer()\n        return { dataState: DataState.LOADED_STATE, appData: response}\n      }),\n      startWith({dataState: DataState.LOADING_STATE}), // waiting for data so we omit response\n      catchError((error: string) => {\n        return of ({dataState: DataState.ERROR_STATE, error }) // if we catch an error\n      })\n    );\n  }\n\n  pingServer(ipAddress: string): void {\n    this.filterSubject.next(ipAddress);\n    this.appState$ = this.serverService.ping$(ipAddress)\n      .pipe(\n        map(response => {\n          const index = this.dataSubject.value.data.servers.findIndex(server =>  server.id === response['data.server.id']);\n          this.dataSubject.value.data.servers[index] = response['data.server'];\n          this.filterSubject.next('');\n          return { dataState: DataState.LOADED_STATE, appData: this.dataSubject.value }\n        }),\n        startWith({ dataState: DataState.LOADED_STATE, appData: this.dataSubject.value }),\n        catchError((error: string) => {\n          this.filterSubject.next('');\n          return of({ dataState: DataState.ERROR_STATE, error });\n        })\n      );\n  }\n\n  // Not getting any new data from the backend because we already have it in response\n\n  filterServer(status: Status): void {\n    \n    this.appState$ = this.serverService.filter$(status, this.dataSubject.value)\n      .pipe(\n        map(response => {\n          \n          return { dataState: DataState.LOADED_STATE, appData: response }\n        }),\n        startWith({ dataState: DataState.LOADED_STATE, appData: this.dataSubject.value }),\n        catchError((error: string) => {\n          \n          return of({ dataState: DataState.ERROR_STATE, error });\n        })\n      );\n  }\n  \n\n\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}